name: Fetch and build layout

on:
  workflow_dispatch:
    inputs:
      layout_id:
        description: "Layout id available in URL https://configure.zsa.io/voyager/layouts/[ID_IS_HERE]/latest"
        required: true
        default: "3aMQz"
      layout_geometry:
        description: "Keyboard type"
        type: choice
        options:
          - moonlander
          - moonlander/reva
          - moonlander/revb
          - planck_ez
          - planck_ez/glow
        default: moonlander

permissions:
  contents: write

jobs:
  fetch-and-build-layout:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: oryx
          fetch-depth: 0

      - name: Download layout source
        id: download-layout-source
        run: |
          # Use a clear GraphQL query to fetch version info
          # We prefer the generic 'moonlander' geometry key if provided, as the API might handle revisions internally
          GEOMETRY="${{ github.event.inputs.layout_geometry }}"
          
          echo "Fetching layout for Geometry: $GEOMETRY"
          
          QUERY='query getLayout($hashId: String!, $revisionId: String!, $geometry: String!) { layout(hashId: $hashId, revisionId: $revisionId, geometry: $geometry) { revision { hashId, qmkVersion, changeDescription } } }'
          VARIABLES="{\"hashId\":\"${{ github.event.inputs.layout_id }}\",\"revisionId\":\"latest\",\"geometry\":\"$GEOMETRY\"}"
          
          # Construct JSON payload
          PAYLOAD=$(jq -n --arg q "$QUERY" --arg v "$VARIABLES" '{query: $q, variables: $v|fromjson}')
          
          # Fetch metadata from Oryx
          curl --location --silent --show-error 'https://oryx.zsa.io/graphql' \
            --header 'Content-Type: application/json' \
            --data "$PAYLOAD" > response.json
            
          # Debug: Print response
          cat response.json

          # Extract values using jq
          HASH_ID=$(jq -r '.data.layout.revision.hashId' response.json)
          FIRMWARE_VERSION=$(jq -r '.data.layout.revision.qmkVersion' response.json)
          CHANGE_DESC=$(jq -r '.data.layout.revision.changeDescription // "Manual build"' response.json)

          # Verify we got a hash (if null/empty, something went wrong)
          if [ "$HASH_ID" == "null" ] || [ -z "$HASH_ID" ]; then
            echo "::error::Failed to retrieve Hash ID from Oryx response. Check that the Layout ID and Geometry match."
            exit 1
          fi

          echo "Found Hash ID: $HASH_ID"
          echo "Firmware Version: $FIRMWARE_VERSION"
          
          # Set outputs
          echo "firmware_version=$FIRMWARE_VERSION" >> "$GITHUB_OUTPUT"
          echo "change_description=$CHANGE_DESC" >> "$GITHUB_OUTPUT"

          # Download the source zip using the SPECIFIC hash
          curl -L "https://oryx.zsa.io/source/$HASH_ID" -o source.zip

      - name: Unzip the source file
        run: |
          unzip -oj source.zip '*_source/*' -d ${{ github.event.inputs.layout_id }}
          rm source.zip
          rm -f response.json

      - name: Validate Layout Type
        run: |
          # Check if the downloaded keymap matches the expected geometry
          if grep -q "LAYOUT_ergodox" ${{ github.event.inputs.layout_id }}/keymap.c; then
            echo "::error::Downloaded layout contains 'LAYOUT_ergodox' but expected Moonlander! The Layout ID might be incorrect or the API returned the wrong version."
            # We don't exit 1 here to allow you to see the file, but we warn heavily
            echo "WARNING: This appears to be an ErgoDox layout."
          elif grep -q "LAYOUT_moonlander" ${{ github.event.inputs.layout_id }}/keymap.c; then
             echo "SUCCESS: Verified 'LAYOUT_moonlander' in keymap.c"
          else
             echo "WARNING: Could not verify layout macro in keymap.c"
          fi

      - name: Commit and Push changes
        env:
          CHANGE_DESCRIPTION: ${{ steps.download-layout-source.outputs.change_description }}
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "✨(oryx): $CHANGE_DESCRIPTION" || echo "No layout change"
          git push origin oryx

      - name: Merge Oryx with custom QMK
        run: |
          git fetch origin main
          git checkout -B main origin/main
          git merge -Xignore-all-space oryx
          git push origin main

      - name: Update QMK firmware submodule (ZSA Fork)
        run: |
          # Initialize submodule
          git submodule update --init --remote --depth=1 --no-single-branch
          
          cd qmk_firmware
          # ENSURE ZSA FORK: Explicitly set remote to ZSA to be safe
          git remote set-url origin https://github.com/zsa/qmk_firmware.git
          git fetch origin
          
          # Checkout the specific firmware branch (e.g., firmware24) used by this layout version
          TARGET_BRANCH="firmware${{ steps.download-layout-source.outputs.firmware_version }}"
          echo "Checking out ZSA branch: $TARGET_BRANCH"
          
          git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH" || {
            echo "Branch $TARGET_BRANCH not found, falling back to default branch."
            git checkout -B firmware24 origin/firmware24 || git checkout master
          }
          
          git submodule update --init --recursive
          cd ..
          
          # Commit the submodule update to main
          git add qmk_firmware
          git commit -m "✨(qmk): Update firmware to $TARGET_BRANCH" || echo "No QMK change"
          git push origin main

      - name: Create QMK Dockerfile
        run: |
          cat > Dockerfile <<'EOF'
          FROM ubuntu:22.04
          ENV DEBIAN_FRONTEND=noninteractive
          
          # Install toolchain and basic dependencies
          RUN apt-get update && apt-get install -y --no-install-recommends \
              ca-certificates curl git build-essential python3 python3-pip \
              gcc-arm-none-eabi binutils-arm-none-eabi dfu-util unzip \
              libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib \
            && apt-get clean && rm -rf /var/lib/apt/lists/*
          
          # Copy requirements from the submodule (must be in build context)
          COPY qmk_firmware/requirements.txt /tmp/requirements.txt
          
          # Install QMK CLI and firmware requirements
          RUN pip3 install --no-cache-dir qmk && \
              pip3 install --no-cache-dir -r /tmp/requirements.txt
          
          WORKDIR /qmk_firmware
          EOF

      - name: Build qmk docker image
        run: docker build -t qmk .

      - name: Build the layout
        id: build-layout
        run: |
          FIRMWARE_VERSION="${{ steps.download-layout-source.outputs.firmware_version }}"
          
          # Dynamic path selection based on ZSA firmware versioning
          if [ "$FIRMWARE_VERSION" -ge 24 ]; then
            KEYBOARD_DIR="qmk_firmware/keyboards/zsa"
            MAKE_PREFIX="zsa/"
          else
            KEYBOARD_DIR="qmk_firmware/keyboards"
            MAKE_PREFIX=""
          fi
          
          echo "Using keyboard directory: $KEYBOARD_DIR"

          # Prepare Layout Directory
          mkdir -p "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps"
          rm -rf "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps/${{ github.event.inputs.layout_id }}"
          cp -r "${{ github.event.inputs.layout_id }}" "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps/${{ github.event.inputs.layout_id }}"

          # Run Make inside Docker
          # We explicitly invoke 'qmk setup' to ensure the environment is correct
          # Note: We use 'moonlander' generic folder name for build if input was moonlander
          # But QMK expects 'moonlander' usually.
          
          # Map geometry input to QMK folder name if needed
          # For Moonlander, it's just 'moonlander'
          # We strip '/reva' etc for the make command if it's there
          QMK_KEYBOARD_NAME=$(echo "${{ github.event.inputs.layout_geometry }}" | cut -d'/' -f1)
          
          docker run --rm -v "$(pwd)/qmk_firmware:/qmk_firmware" qmk /bin/sh -c "
            qmk setup -y -H /qmk_firmware && \
            make ${MAKE_PREFIX}${QMK_KEYBOARD_NAME}:${{ github.event.inputs.layout_id }}
          "

          # Find and Export Artifact
          NORMALIZED_GEOMETRY=$(echo "${{ github.event.inputs.layout_geometry }}" | sed 's/\//_/g')
          BUILT_FILE=$(find ./qmk_firmware -type f -regex ".*${QMK_KEYBOARD_NAME}.*\.\(bin\|hex\)" -print -quit)
          
          echo "built_layout_file=${BUILT_FILE}" >> "$GITHUB_OUTPUT"
          echo "normalized_layout_geometry=${NORMALIZED_GEOMETRY}" >> "$GITHUB_OUTPUT"

      - name: Upload layout
        if: steps.build-layout.outputs.built_layout_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-layout.outputs.normalized_layout_geometry }}_${{ github.event.inputs.layout_id }}
          path: ${{ steps.build-layout.outputs.built_layout_file }}
