name: Fetch and build layout

on:
  workflow_dispatch:
    inputs:
      layout_id:
        description: "Layout id from URL: https://configure.zsa.io/moonlander/layouts/[ID]/latest"
        required: true
        default: "3aMQz"
      layout_geometry:
        description: "Moonlander hardware revision (must match Oryx/QMK geometry)"
        type: choice
        options:
          - moonlander/reva
          - moonlander/revb
        default: moonlander/revb

permissions:
  contents: write

jobs:
  fetch-and-build-layout:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository (oryx branch)
        uses: actions/checkout@v4
        with:
          ref: oryx
          fetch-depth: 0

      - name: Download layout source
        id: download-layout-source
        shell: bash
        run: |
          set -euo pipefail

          LAYOUT_ID="${{ github.event.inputs.layout_id }}"
          GEOMETRY="${{ github.event.inputs.layout_geometry }}"

          # Upstream query shape: revision { hashId, qmkVersion, title }
          payload=$(jq -n --arg hid "$LAYOUT_ID" --arg geo "$GEOMETRY" --arg rev "latest" '{
            query: "query getLayout($hashId: String!, $revisionId: String!, $geometry: String) { layout(hashId: $hashId, geometry: $geometry, revisionId: $revisionId) { revision { hashId, qmkVersion, title }}}",
            variables: { hashId: $hid, geometry: $geo, revisionId: $rev }
          }')

          curl -fsSL 'https://oryx.zsa.io/graphql' \
            -H 'Content-Type: application/json' \
            --data "$payload" > response.json

          hash_id=$(jq -r '.data.layout.revision.hashId' response.json)
          qmk_version=$(jq -r '.data.layout.revision.qmkVersion' response.json)
          title=$(jq -r '.data.layout.revision.title // empty' response.json)

          if [[ -z "$hash_id" || "$hash_id" == "null" ]]; then
            echo "::error::Oryx returned null hashId. Check layout visibility and that geometry matches (moonlander/reva vs moonlander/revb)."
            jq -c '.errors? // empty' response.json || true
            exit 1
          fi

          firmware_version=$(printf "%.0f" "$qmk_version")
          change_description="${title:-latest layout modification made with Oryx}"

          curl -fsSL "https://oryx.zsa.io/source/${hash_id}" -o source.zip

          echo "firmware_version=$firmware_version" >> "$GITHUB_OUTPUT"
          echo "change_description=$change_description" >> "$GITHUB_OUTPUT"

      - name: Unzip the source file
        shell: bash
        run: |
          set -euo pipefail
          unzip -oj source.zip '*_source/*' -d "${{ github.event.inputs.layout_id }}"
          rm -f source.zip response.json

      - name: Fetch Patch Script (from main)
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL "https://raw.githubusercontent.com/${{ github.repository }}/main/scripts/patch_keymap.py" -o patch_keymap.py

      - name: Apply Custom Injections
        shell: bash
        run: |
          set -euo pipefail
          python3 patch_keymap.py "${{ github.event.inputs.layout_id }}/keymap.c"

      - name: Commit and Push Oryx changes
        env:
          CHANGE_DESCRIPTION: ${{ steps.download-layout-source.outputs.change_description }}
        shell: bash
        run: |
          set -euo pipefail
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .
          printf "✨(oryx): %s\n" "$CHANGE_DESCRIPTION" | git commit -F - || echo "No layout change"
          git push origin oryx

      - name: Merge Oryx into main
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main
          git checkout -B main origin/main
          git merge -Xignore-all-space oryx
          git push origin main

      - name: Update QMK firmware submodule (match Oryx qmkVersion)
        shell: bash
        run: |
          set -euo pipefail
          git submodule update --init --remote --depth=1 --no-single-branch
          cd qmk_firmware

          git remote set-url origin https://github.com/zsa/qmk_firmware.git
          git fetch origin --prune

          TARGET_BRANCH="firmware${{ steps.download-layout-source.outputs.firmware_version }}"
          if git show-ref --verify --quiet "refs/remotes/origin/${TARGET_BRANCH}"; then
            git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH"
          else
            echo "Branch $TARGET_BRANCH not found; falling back to firmware24 (or master)."
            git checkout -B firmware24 origin/firmware24 || git checkout master
          fi

          git submodule update --init --recursive
          cd ..

          git add qmk_firmware
          git commit -m "✨(qmk): Update firmware to ${TARGET_BRANCH}" || echo "No QMK change"
          git push origin main

      - name: Build qmk docker image
        run: docker build -t qmk .

      - name: Build the layout
        id: build-layout
        shell: bash
        run: |
          set -euo pipefail

          LAYOUT_ID="${{ github.event.inputs.layout_id }}"
          GEOMETRY="${{ github.event.inputs.layout_geometry }}"
          FIRMWARE_VERSION="${{ steps.download-layout-source.outputs.firmware_version }}"

          # Follow upstream: for firmware >= 24, keyboard path is under keyboards/zsa and make prefix is zsa/
          if [ "$FIRMWARE_VERSION" -ge 24 ]; then
            keyboard_directory="qmk_firmware/keyboards/zsa"
            make_prefix="zsa/"
          else
            keyboard_directory="qmk_firmware/keyboards"
            make_prefix=""
          fi

          # Copy layout into the correct QMK keymaps folder (geometry includes /reva or /revb)
          rm -rf "${keyboard_directory}/${GEOMETRY}/keymaps/${LAYOUT_ID}"
          mkdir -p "${keyboard_directory}/${GEOMETRY}/keymaps"
          cp -r "${LAYOUT_ID}" "${keyboard_directory}/${GEOMETRY}/keymaps/${LAYOUT_ID}"

          docker run --rm -v "$(pwd)/qmk_firmware:/root" qmk /bin/sh -c "
            qmk setup zsa/qmk_firmware -b firmware${FIRMWARE_VERSION} -y
            make ${make_prefix}${GEOMETRY}:${LAYOUT_ID}
          "

          normalized_geometry="$(echo "$GEOMETRY" | sed 's/\//_/g')"
          built_file="$(find ./qmk_firmware -maxdepth 1 -type f -regex ".*${normalized_geometry}.*\.\(bin\|hex\)$" -print -quit)"

          if [ -z "$built_file" ]; then
            echo "::error::Build succeeded but artifact not found in ./qmk_firmware root."
            exit 1
          fi

          echo "built_layout_file=${built_file}" >> "$GITHUB_OUTPUT"
          echo "normalized_layout_geometry=${normalized_geometry}" >> "$GITHUB_OUTPUT"

      - name: Upload layout
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-layout.outputs.normalized_layout_geometry }}_${{ github.event.inputs.layout_id }}
          path: ${{ steps.build-layout.outputs.built_layout_file }}
