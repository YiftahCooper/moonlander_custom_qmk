name: Fetch and build layout

on:
  workflow_dispatch:
    inputs:
      layout_id:
        description: "Layout id available in URL https://configure.zsa.io/voyager/layouts/[ID_IS_HERE]/latest"
        required: true
        default: "3aMQz"
      layout_geometry:
        description: "Keyboard type"
        type: choice
        options:
          - moonlander/reva
          - moonlander/revb
          - planck_ez
          - planck_ez/glow
        default: moonlander/reva

permissions:
  contents: write

jobs:
  fetch-and-build-layout:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: oryx
          fetch-depth: 0

      - name: Download layout source
        id: download-layout-source
        run: |
          # Use a clear GraphQL query to fetch version info
          QUERY='query getLayout($hashId: String!, $revisionId: String!, $geometry: String!) { layout(hashId: $hashId, revisionId: $revisionId, geometry: $geometry) { revision { hashId, qmkVersion, changeDescription } } }'
          VARIABLES="{\"hashId\":\"${{ github.event.inputs.layout_id }}\",\"revisionId\":\"latest\",\"geometry\":\"${{ github.event.inputs.layout_geometry }}\"}"
          
          # We use jq to construct the JSON payload correctly to avoid quoting issues
          PAYLOAD=$(jq -n --arg q "$QUERY" --arg v "$VARIABLES" '{query: $q, variables: $v|fromjson}')
          
          RESPONSE=$(curl --location --silent --show-error 'https://oryx.zsa.io/graphql' \
            --header 'Content-Type: application/json' \
            --data "$PAYLOAD")

          # Parse with Python for reliability
          echo "$RESPONSE" | python3 -c "
          import sys, json
          try:
              data = json.load(sys.stdin)
              rev = data['data']['layout']['revision']
              print(f\"firmware_version={int(rev['qmkVersion'])}\")
              print(f\"change_description={rev['changeDescription'] or 'Manual build'}\")
              print(f\"hash_id={rev['hashId']}\")
          except Exception as e:
              print(f\"Error parsing Oryx response: {e}\", file=sys.stderr)
              # Fallback to defaults if API fails
              print('firmware_version=24')
              print('change_description=Fallback build')
              print('hash_id=${{ github.event.inputs.layout_id }}')
          " >> "$GITHUB_OUTPUT"

          # Download the source zip
          curl -L "https://oryx.zsa.io/source/${{ github.event.inputs.layout_id }}" -o source.zip

      - name: Unzip the source file
        run: |
          unzip -oj source.zip '*_source/*' -d ${{ github.event.inputs.layout_id }}
          rm source.zip

      - name: Commit and Push changes
        env:
          CHANGE_DESCRIPTION: ${{ steps.download-layout-source.outputs.change_description }}
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "✨(oryx): $CHANGE_DESCRIPTION" || echo "No layout change"
          git push origin oryx

      - name: Merge Oryx with custom QMK
        run: |
          git fetch origin main
          git checkout -B main origin/main
          git merge -Xignore-all-space oryx
          git push origin main

      - name: Update QMK firmware submodule (ZSA Fork)
        run: |
          # Initialize submodule
          git submodule update --init --remote --depth=1 --no-single-branch
          
          cd qmk_firmware
          # ENSURE ZSA FORK: Explicitly set remote to ZSA to be safe
          git remote set-url origin https://github.com/zsa/qmk_firmware.git
          git fetch origin
          
          # Checkout the specific firmware branch (e.g., firmware24) used by this layout version
          TARGET_BRANCH="firmware${{ steps.download-layout-source.outputs.firmware_version }}"
          echo "Checking out ZSA branch: $TARGET_BRANCH"
          
          git checkout -B "$TARGET_BRANCH" "origin/$TARGET_BRANCH" || {
            echo "Branch $TARGET_BRANCH not found, falling back to default branch."
            git checkout -B firmware24 origin/firmware24 || git checkout master
          }
          
          git submodule update --init --recursive
          cd ..
          
          # Commit the submodule update to main
          git add qmk_firmware
          git commit -m "✨(qmk): Update firmware to $TARGET_BRANCH" || echo "No QMK change"
          git push origin main

      - name: Create QMK Dockerfile
        run: |
          cat > Dockerfile <<'EOF'
          FROM ubuntu:22.04
          ENV DEBIAN_FRONTEND=noninteractive
          
          # Install toolchain and basic dependencies
          RUN apt-get update && apt-get install -y --no-install-recommends \
              ca-certificates curl git build-essential python3 python3-pip \
              gcc-arm-none-eabi binutils-arm-none-eabi dfu-util unzip \
              libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib \
            && apt-get clean && rm -rf /var/lib/apt/lists/*
          
          # Copy requirements from the submodule (must be in build context)
          COPY qmk_firmware/requirements.txt /tmp/requirements.txt
          
          # Install QMK CLI and firmware requirements
          RUN pip3 install --no-cache-dir qmk && \
              pip3 install --no-cache-dir -r /tmp/requirements.txt
          
          WORKDIR /qmk_firmware
          EOF

      - name: Build qmk docker image
        run: docker build -t qmk .

      - name: Build the layout
        id: build-layout
        run: |
          FIRMWARE_VERSION="${{ steps.download-layout-source.outputs.firmware_version }}"
          
          # Dynamic path selection based on ZSA firmware versioning
          if [ "$FIRMWARE_VERSION" -ge 24 ]; then
            KEYBOARD_DIR="qmk_firmware/keyboards/zsa"
            MAKE_PREFIX="zsa/"
          else
            KEYBOARD_DIR="qmk_firmware/keyboards"
            MAKE_PREFIX=""
          fi
          
          echo "Using keyboard directory: $KEYBOARD_DIR"

          # Prepare Layout Directory
          mkdir -p "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps"
          rm -rf "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps/${{ github.event.inputs.layout_id }}"
          cp -r "${{ github.event.inputs.layout_id }}" "${KEYBOARD_DIR}/${{ github.event.inputs.layout_geometry }}/keymaps/${{ github.event.inputs.layout_id }}"

          # Run Make inside Docker
          # We explicitly invoke 'qmk setup' to ensure the environment is correct
          docker run --rm -v "$(pwd)/qmk_firmware:/qmk_firmware" qmk /bin/sh -c "
            qmk setup -y -H /qmk_firmware && \
            make ${MAKE_PREFIX}${{ github.event.inputs.layout_geometry }}:${{ github.event.inputs.layout_id }}
          "

          # Find and Export Artifact
          NORMALIZED_GEOMETRY=$(echo "${{ github.event.inputs.layout_geometry }}" | sed 's/\//_/g')
          BUILT_FILE=$(find ./qmk_firmware -type f -regex ".*${NORMALIZED_GEOMETRY}.*\.\(bin\|hex\)" -print -quit)
          
          echo "built_layout_file=${BUILT_FILE}" >> "$GITHUB_OUTPUT"
          echo "normalized_layout_geometry=${NORMALIZED_GEOMETRY}" >> "$GITHUB_OUTPUT"

      - name: Upload layout
        if: steps.build-layout.outputs.built_layout_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-layout.outputs.normalized_layout_geometry }}_${{ github.event.inputs.layout_id }}
          path: ${{ steps.build-layout.outputs.built_layout_file }}
